Metadata-Version: 2.4
Name: sar
Version: 0.1.0
Summary: Security Application Registry (SAR)
License: AGPL-3.0-or-later
Project-URL: Homepage, https://example.invalid/sar
Requires-Python: >=3.10
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: fastapi
Requires-Dist: uvicorn
Requires-Dist: pandas
Requires-Dist: openpyxl
Requires-Dist: jinja2
Requires-Dist: python-multipart
Dynamic: license-file

![License: AGPL v3](https://img.shields.io/badge/License-AGPL%20v3-blue.svg)


# Security Application Registry (SAR)

SAR (Security Application Registry) es un registro operativo de aplicaciones orientado a **Application Security** y **Secure Architecture**. Su objetivo es hacer el riesgo **visible, derivable y accionable** a partir de un modelo estructurado, con **Excel como “source of truth”** y un motor en Python para validar, calcular vistas y detectar inconsistencias.

> Autor / Maintainer: Bernardo Gómez Bey

## Contexto y alcance

SAR no pretende sustituir herramientas de arquitectura empresarial, CMDBs ni plataformas de gobierno.

Proporciona una **visión operativa y específica** orientada a desarrollo y ciberseguridad, basada en cómo el software se desarrolla, se despliega y se ejecuta realmente. En lugar de modelar arquitecturas ideales o exhaustivas, SAR modela **proyectos, aplicaciones, componentes de código y sus contextos de ejecución concretos**, que es donde se materializan los cambios y el riesgo.

El objetivo es reducir fricción entre desarrollo, seguridad y herramientas corporativas, capturando únicamente información que los equipos pueden mantener de forma realista, pero con suficiente estructura para servir como input fiable a plataformas más amplias.

---

## Modelo (C1–C4)

SAR utiliza un modelo jerárquico de cuatro niveles para representar aplicaciones desde una perspectiva de **negocio, código y ejecución**, manteniendo cada responsabilidad claramente separada.

### C1 — Proyecto (unidad de negocio)
Unidad de negocio y gobierno. Representa el nivel más alto de responsabilidad (sponsor/ownership) bajo el cual existen una o más aplicaciones.

Los proyectos **no contienen código** ni describen ejecución técnica.

### C2 — Aplicación (unidad funcional)
Unidad funcional de negocio. Vive bajo un proyecto (C1) y agrupa uno o varios componentes técnicos que la implementan.

La aplicación describe el **qué** (función), no el **cómo** (implementación) ni el **dónde** (ejecución).

### C3 — Componente (unidad de código)
Unidad técnica de código dentro de una aplicación (por ejemplo: frontend, backend, API, worker).

Es el nivel donde:
- existe el código,
- se define el repositorio,
- viven decisiones técnicas y el SDLC.

Un componente **no está ligado a un único entorno ni a un único runtime**.  
El mismo C3 puede ejecutarse en múltiples contextos distintos.

### C4 — Runtime (contexto de ejecución)
Contexto concreto donde se ejecuta un componente. No describe infraestructura física, pero sí atributos relevantes para seguridad (entorno, exposición, red/zona, riesgos).

Cada C4 está asociado a **un único C3**, pero un C3 puede tener **múltiples C4**.

### Invariantes del modelo
- No existe C4 sin C3.
- No existe C3 sin C2.
- No existe C2 sin C1.
- Debe existir al menos una cadena completa `C1 → C2 → C3 → C4`.

---

## Validación dinámica (LOOKUPS & RULES)
SAR utiliza un enfoque dinámico y basado en convención para validar datos y aplicar reglas.

### LOOKUPS
La hoja LOOKUPS define valores permitidos para determinados campos mediante:
- lookup_name
- lookup_value
- level (C1–C4 o ALL)

Regla de funcionamiento:
- Si existe un lookup_name = X, y existe una columna X en la hoja correspondiente, SAR valida automáticamente sus valores.

No existen mappings hardcodeados entre campos y lookups.
La validación se activa únicamente por coincidencia de nombre (lookup_name == column_name).

Si un lookup está definido pero la columna no existe en la hoja correspondiente, se genera una ISSUE de configuración, pero el sistema no falla.

### RULES
La hoja RULES permite definir reglas declarativas por nivel (C1–C4).
- Las reglas se aplican dinámicamente.
- Si una regla referencia un campo que no existe, se genera una ISSUE de configuración.
- Las reglas nunca provocan fallos estructurales del motor.

### Validaciones Core
Independientemente de LOOKUPS y RULES, SAR aplica siempre validaciones estructurales mínimas:
- human_id
- status
- name
- referencias jerárquicas (c1_human_id, c2_human_id, c3_human_id)
- coherencia del modelo C1 → C2 → C3 → C4

Estas validaciones son prioritarias y no dependen del contenido dinámico del Excel.

### Campos especiales
Algunos campos pueden tener lógica derivada (por ejemplo vulnerabilities_detected).
Si estos campos no existen en el modelo, SAR genera una ISSUE informativa y omite su cálculo.

---
## Requisitos

- Python **3.10+**
- Dependencias en `requirements.txt`

---

## Instalación

```bash
pip install -e .
```

---

## Ejecución

```bash
uvicorn sar.app:app --reload
```

Abrir: http://localhost:8000

---

## Licencia

Este proyecto se publica bajo **GNU Affero General Public License v3.0 (AGPLv3)**.

© **2026** — **Bernardo Gómez Bey**
